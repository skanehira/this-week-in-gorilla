---
head:
  - - meta
    - name: twitter:card
      content: summary_large_image
  - - meta
    - property: og:site_name
      content: This Week in Gorilla
  - - meta
    - property: og:title
      content: 2023/11 2週目

title: "2023/11 2週目"
---

# {{ $frontmatter.title }}

## コンテナ
- [Docker Desktop、Appleシリコン上でx86-64バイナリをほぼネイティブな速度で実行可能にする「Rosetta for Linux」が正式版に](https://www.publickey1.jp/blog/23/docker_desktopapplex86-64rosetta_for_linux.html)
- https://x.com/toricls/status/1721877821872873533?s=20
  - コンテナイメージの lazy loading について解説してくれているツイート
  - <details><summary>詳細</summary>
    <p>
    
    超絶ざっくり書くと、以下のような感じです！
    (当たり前すぎる話を書いていたり雑すぎて正確性が足りなかったりするところも一部ありますがご容赦ください🙇‍♂️)
    
    コンテナイメージの lazy loading について
    ・普通にコンテナを実行しようとするとコンテナイメージをダウンロード → 実行という流れになるんですが、これはつまりダウンロードが完了するまでの時間は完全に「待ち」の時間になる
    ・これはつまりコンテナイメージのダウンロード時間に応じてコンテナの起動までの時間が長くなることを意味するのですが、例えばコンテナがクラッシュした！再起動だ！イメージのダウンロードだ！となると、イメージサイズが大きければ大きいほどダウンタイムが長時間化することが予想されます (Fargate のようなコンテナイメージのキャッシュが存在しない実行環境だと余計に)
    ・ここであらためてコンテナイメージとはなんだったかを振り返ると、コンテナイメージは「それぞれがファイルを含んだレイヤー」が重なった構造になっているので、つまりコンテナイメージのダウンロードとは、レイヤーをそれぞれダウンロードしてきてローカルでがっちゃんこしているという処理を意味します
    ・であれば、まずはコンテナの実行に最低限必要となるレイヤーだけをダウンロードしてきた上でコンテナを実行し、残りのレイヤーのダウンロードは必要になるタイミングまで先送りする(=lazy loading)すれば、大きなサイズのコンテナイメージでもダウンロード時間からくる起動待ち時間というペナルティを最小化できるのでは、というのがコンテナイメージの lazy loading の基本的なアイデアです
    
    ECS/Fargate におけるこれまでの lazy loading について
    ・ではどんなイメージでもそのまま lazy loading ができるのかというとそんなこともなくて、どのファイルがどのレイヤーに含まれているかをコンテナランタイムに教えてあげるための「インデックス」を事前に作っておいてあげる必要があります
    ・ECS/Fargate では、「SOCI インデックス」というインデックスを利用した lazy loading をサポートしています
    ・で、ECS ではタスク定義に複数のコンテナを含める(e.g. アプリケーションコンテナ + ログ用コンテナ + メトリクス用コンテナ、とか)ことができますが、これまでは「lazy loading を使いたい場合には、タスク定義に含まれる『すべての』コンテナイメージについて、SOCI インデックスを事前に作っておいてね」という仕様でした
    ・これの何が困るかと言うと、単に事前に全部のインデックス作るのでめんどくさいよねということに加えて、例えば小さなコンテナイメージで lazy loading されてしまうと逆に起動が遅くなるようなケースで悲しい気持ちになったりします
    ・ので、タスク定義に含まれる複数のコンテナイメージのうち、lazy loading する意味があるものだけを lazy loading したいぜというのが自然なニーズとして登場します
    
    今回のリリース内容について
    ・で、今回のリリースで何が変わったのかというと、これまでの「lazy loading をしたい場合はタスク定義に含まれるすべてのコンテナイメージの SOCI インデックスが必要です(、つまり1つでも lazy loading したいコンテナイメージがある場合は、結果として望む望まないに関係なくタスク定義に含まれるすべてのコンテナイメージについて必ず lazy loading する必要があります)」という制約がなくなり、「lazy loading したいコンテナイメージの SOCI インデックスだけ用意していれば、タスク定義の中で SOCI インデックスが用意されているコンテナイメージは lazy loading するけど、SOCI インデックスが用意されていないコンテナイメージについては普通にダウンロードして起動するよ」、みたいな挙動になりました！(わーい)
    
    </p>
    </details> 
  - https://github.com/containerd/stargz-snapshotter
    - lazy pulling のプラグインらしい
    - lazy loading と pulling の違いなどについて一度整理したい

## AI
- [OpenAI がまたやった！OpenAI DevDay 総まとめ](https://chatgpt-lab.com/n/n0554df7f1b80)
- https://vectorizer.ai
  - AIを使って画質を良くしてくれるやつ

## CI
- [GitHub Appsトークン解体新書：GitHub ActionsからPATを駆逐する技術](https://zenn.dev/tmknom/articles/github-apps-token)
